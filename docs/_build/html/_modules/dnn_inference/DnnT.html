

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dnn_inference.DnnT &mdash; dnn-inference  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> dnn-inference
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Dnn-Inference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../python-api/Dnn.html">Python-API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dnn-inference</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>dnn_inference.DnnT</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for dnn_inference.DnnT</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Statistical inference based on deep nerual networks</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Author: Ben Dai &lt;bdai@umn.edu&gt;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">keras.callbacks</span> <span class="kn">import</span> <span class="n">EarlyStopping</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">keras.backend</span> <span class="k">as</span> <span class="nn">K</span>
<span class="kn">from</span> <span class="nn">keras.initializers</span> <span class="kn">import</span> <span class="n">glorot_uniform</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">hmean</span><span class="p">,</span> <span class="n">gmean</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<div class="viewcode-block" id="DnnT"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT">[docs]</a><span class="k">class</span> <span class="nc">DnnT</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Class for one-split/two-split test based on deep neural networks. </span>
<span class="sd">	</span>
<span class="sd">	Parameters</span>
<span class="sd">	----------</span>

<span class="sd">	inf_cov : list-like of shape (num of tests, dim of features)</span>
<span class="sd">	 List of covariates/Features under hypothesis testings, one element corresponding to a hypothesis testing.</span>

<span class="sd">	model : {keras-defined neural network}</span>
<span class="sd">	 A neural network for original full dataset</span>
<span class="sd">	</span>
<span class="sd">	model_mask : {keras-defined neural network}</span>
<span class="sd">	 A neural network for masked dataset by masking/changing the features under hypothesis testing</span>

<span class="sd">	change: {&#39;mask&#39;, &#39;perm&#39;}, default=&#39;mask&#39;</span>
<span class="sd">	 The way to change the testing features, ``&#39;mask&#39;`` replaces testing features as zeros, while ``&#39;perm&#39;`` permutes features via instances.</span>

<span class="sd">	alpha: float (0,1), default=0.05</span>
<span class="sd">	 The nominal level of the hypothesis testing</span>
<span class="sd">	</span>
<span class="sd">	verbose: {0, 1}, default=0</span>
<span class="sd">	 If print the testing results, 1 indicates YES, 0 indicates NO.</span>
<span class="sd">	</span>
<span class="sd">	eva_metric: {&#39;mse&#39;, &#39;zero-one&#39;, &#39;cross-entropy&#39;, or custom metric function}</span>
<span class="sd">	 The evaluation metric, ``&#39;mse&#39;`` is the l2-loss for regression, ``&#39;zero-one&#39;`` is the zero-one loss for classification, ``&#39;cross-entropy&#39;`` is log-loss for classification. It can also be custom metric function as ``eva_metric(y_true, y_pred)``.</span>
<span class="sd">	</span>
<span class="sd">	cp_path: {string}, default=&#39;./checkpoints&#39;</span>
<span class="sd">	 The checkpoints path to save the models</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inf_cov</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">change</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eva_metric</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">,</span> <span class="n">cp_path</span> <span class="o">=</span> <span class="s1">&#39;./checkpoints&#39;</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span> <span class="o">=</span> <span class="n">inf_cov</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span> <span class="o">=</span> <span class="n">model_mask</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">=</span> <span class="n">change</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">eva_metric</span> <span class="o">=</span> <span class="n">eva_metric</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span> <span class="o">=</span> <span class="n">cp_path</span>

<div class="viewcode-block" id="DnnT.metric"><a class="viewcode-back" href="../../dnn_inference.html#dnn_inference.DnnT.DnnT.metric">[docs]</a>	<span class="k">def</span> <span class="nf">metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eva_metric</span> <span class="o">==</span> <span class="s1">&#39;mse&#39;</span><span class="p">:</span>
			<span class="n">metric_tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">eva_metric</span> <span class="o">==</span> <span class="s1">&#39;mae&#39;</span><span class="p">:</span>
			<span class="n">metric_tmp</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">eva_metric</span> <span class="o">==</span> <span class="s1">&#39;zero-one&#39;</span><span class="p">:</span>
			<span class="n">label_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">label_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">metric_tmp</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">label_true</span> <span class="o">==</span> <span class="n">label_pred</span><span class="p">)</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">eva_metric</span> <span class="o">==</span> <span class="s1">&#39;cross-entropy&#39;</span><span class="p">:</span>
			<span class="n">label_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">metric_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_pred</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)),</span><span class="n">label_true</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">metric_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eva_metric</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">metric_tmp</span></div>

<div class="viewcode-block" id="DnnT.save_init"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.save_init">[docs]</a>	<span class="k">def</span> <span class="nf">save_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Save the initialization for full and mask network models under class Dnn</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/model_init.h5&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/model_mask_init.h5&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DnnT.reset_model"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.reset_model">[docs]</a>	<span class="k">def</span> <span class="nf">reset_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Reset the full and mask network models under class Dnn</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/model_init.h5&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/model_mask_init.h5&#39;</span><span class="p">)</span></div>

	<span class="c1"># def reset_model(self):</span>
	<span class="c1"># 	&quot;&quot;&quot;</span>
	<span class="c1"># 	Reset the full and mask network models under class Dnn</span>
	<span class="c1"># 	&quot;&quot;&quot;</span>
	<span class="c1"># 	if int(tf.__version__[0]) == 2:</span>
	<span class="c1"># 		for layer in self.model.layers:</span>
	<span class="c1"># 			if isinstance(layer, tf.keras.Model): #if you&#39;re using a model as a layer</span>
	<span class="c1"># 				reset_weights(layer) #apply function recursively</span>
	<span class="c1"># 				continue</span>
	<span class="c1"># 			#where are the initializers?</span>
	<span class="c1"># 			if hasattr(layer, &#39;cell&#39;):</span>
	<span class="c1"># 				init_container = layer.cell</span>
	<span class="c1"># 			else:</span>
	<span class="c1"># 				init_container = layer</span>

	<span class="c1"># 			for key, initializer in init_container.__dict__.items():</span>
	<span class="c1"># 				if &quot;initializer&quot; not in key: #is this item an initializer?</span>
	<span class="c1"># 				  continue #if no, skip it</span>
	<span class="c1"># 				# find the corresponding variable, like the kernel or the bias</span>
	<span class="c1"># 				if key == &#39;recurrent_initializer&#39;: #special case check</span>
	<span class="c1"># 					var = getattr(init_container, &#39;recurrent_kernel&#39;)</span>
	<span class="c1"># 				else:</span>
	<span class="c1"># 					var = getattr(init_container, key.replace(&quot;_initializer&quot;, &quot;&quot;))</span>
					
	<span class="c1"># 				if var is None:</span>
	<span class="c1"># 					continue</span>
	<span class="c1"># 				else:</span>
	<span class="c1"># 					var.assign(initializer(var.shape, var.dtype))</span>

	<span class="c1"># 	for layer in self.model_mask.layers:</span>
	<span class="c1"># 		if isinstance(layer, tf.keras.Model): #if you&#39;re using a model as a layer</span>
	<span class="c1"># 			reset_weights(layer) #apply function recursively</span>
	<span class="c1"># 			continue</span>
	<span class="c1"># 		#where are the initializers?</span>
	<span class="c1"># 		if hasattr(layer, &#39;cell&#39;):</span>
	<span class="c1"># 			init_container = layer.cell</span>
	<span class="c1"># 		else:</span>
	<span class="c1"># 			init_container = layer</span>

	<span class="c1"># 		for key, initializer in init_container.__dict__.items():</span>
	<span class="c1"># 			if &quot;initializer&quot; not in key: #is this item an initializer?</span>
	<span class="c1"># 			  continue #if no, skip it</span>
	<span class="c1"># 			# find the corresponding variable, like the kernel or the bias</span>
	<span class="c1"># 			if key == &#39;recurrent_initializer&#39;: #special case check</span>
	<span class="c1"># 				var = getattr(init_container, &#39;recurrent_kernel&#39;)</span>
	<span class="c1"># 			else:</span>
	<span class="c1"># 				var = getattr(init_container, key.replace(&quot;_initializer&quot;, &quot;&quot;))</span>
				
	<span class="c1"># 			if var is None:</span>
	<span class="c1"># 				continue</span>
	<span class="c1"># 			else:</span>
	<span class="c1"># 				var.assign(initializer(var.shape, var.dtype))</span>
		
	<span class="c1"># 	if int(tf.__version__[0]) == 1:</span>
	<span class="c1"># 		session = K.get_session()</span>
	<span class="c1"># 		for layer in self.model.layers:</span>
	<span class="c1"># 			if ((hasattr(layer, &#39;kernel_initializer&#39;)) and (layer.kernel != None)):</span>
	<span class="c1"># 				layer.kernel.initializer.run(session=session)</span>
	<span class="c1"># 			if ((hasattr(layer, &#39;bias_initializer&#39;)) and (layer.bias != None)):</span>
	<span class="c1"># 				layer.bias.initializer.run(session=session)	 </span>
	<span class="c1"># 		for layer in self.model_mask.layers:</span>
	<span class="c1"># 			if ((hasattr(layer, &#39;kernel_initializer&#39;)) and (layer.kernel != None)):</span>
	<span class="c1"># 				layer.kernel.initializer.run(session=session)</span>
	<span class="c1"># 			if ((hasattr(layer, &#39;bias_initializer&#39;)) and (layer.bias != None)):</span>
	<span class="c1"># 				layer.bias.initializer.run(session=session)</span>

	<span class="c1">## can be extent to @abstractmethod</span>
<div class="viewcode-block" id="DnnT.mask_cov"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.mask_cov">[docs]</a>	<span class="k">def</span> <span class="nf">mask_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return instances with masked k-th hypothesized features.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		X : array-like</span>
<span class="sd">		 Target instances.</span>

<span class="sd">		k : integer, default = 0</span>
<span class="sd">		 k-th hypothesized features in inf_cov</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
			<span class="c1">## for channels_last image data: shape should be (#samples, img_rows, img_cols, channel)</span>
			<span class="n">Z</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Z</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">=</span> <span class="mf">0.</span>
		<span class="k">return</span> <span class="n">Z</span></div>

<div class="viewcode-block" id="DnnT.perm_cov"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.perm_cov">[docs]</a>	<span class="k">def</span> <span class="nf">perm_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return instances with permuted k-th hypothesized features.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		X : array-like</span>
<span class="sd">		 Target instances.</span>

<span class="sd">		k : integer, default = 0</span>
<span class="sd">		 k-th hypothesized features in inf_cov</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
			<span class="c1">## for channels_last image data: shape should be (#samples, img_rows, img_cols, channel)</span>
			<span class="n">Z</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">Z</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Z</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">Z</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
		<span class="k">return</span> <span class="n">Z</span></div>

<div class="viewcode-block" id="DnnT.noise_cov"><a class="viewcode-back" href="../../dnn_inference.html#dnn_inference.DnnT.DnnT.noise_cov">[docs]</a>	<span class="k">def</span> <span class="nf">noise_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">Z</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">Z</span></div>

<div class="viewcode-block" id="DnnT.adaRatio"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.adaRatio">[docs]</a>	<span class="k">def</span> <span class="nf">adaRatio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="p">{},</span> <span class="n">perturb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="s1">&#39;one-split&#39;</span><span class="p">,</span> <span class="n">perturb_grid</span><span class="o">=</span><span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span> <span class="o">.</span><span class="mi">05</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="n">ratio_grid</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">8</span><span class="p">],</span> 
				<span class="n">if_reverse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_inf</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_est</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ratio_method</span><span class="o">=</span><span class="s1">&#39;fuse&#39;</span><span class="p">,</span> <span class="n">num_perm</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">cv_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cp</span><span class="o">=</span><span class="s1">&#39;hommel&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return a data-adaptive splitting ratio and perturbation level.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		X : array-like | shape=(n_samples, dim1, dim2, ...)</span>
<span class="sd">			Features. </span>

<span class="sd">		y : array-like | shape=(n_samples, dim)</span>
<span class="sd">			Outcomes.</span>

<span class="sd">		k : integer, default = 0</span>
<span class="sd">			k-th hypothesized features in inf_cov</span>

<span class="sd">		fit_params : dict | shape = dict of fitting parameters</span>
<span class="sd">			See keras ``fit``: (https://keras.rstudio.com/reference/fit.html), including ``batch_size``, ``epoch``, ``callbacks``, ``validation_split``, ``validation_data``.</span>

<span class="sd">		perturb : float | default=None</span>
<span class="sd">			Perturb level for the one-split test, if ``perturb = None``, then the perturb level is determined by adaptive tunning.</span>
<span class="sd">		</span>
<span class="sd">		split : {&#39;one-split&#39;, &#39;two-split&#39;}</span>
<span class="sd">			one-split or two-split test statistic.</span>

<span class="sd">		perturb_grid : list of float | default=[.01, .05, .1, .5, 1.]</span>
<span class="sd">			A list of perturb levels under searching.</span>

<span class="sd">		ratio_grid : list of float (0,1) | default=[.2, .4, .6, .8]</span>
<span class="sd">			A list of estimation/inference ratios under searching.</span>

<span class="sd">		if_reverse: {0,1} | default = 0</span>
<span class="sd">			``if_reverse = 0`` indicates the loop of ``ratio_grid`` starts from smallest one to largest one; ``if_reverse = 1`` indicates the loop of ``ratio_grid`` starts from largest one to smallest one.</span>

<span class="sd">		min_inf: integer | default = 0</span>
<span class="sd">			The minimal size for inference sample.</span>

<span class="sd">		min_est: integer | default = 0</span>
<span class="sd">			The minimal size for estimation sample.</span>

<span class="sd">		ratio_method: {&#39;close&#39;, &#39;fuse&#39;} | default = &#39;fuse&#39;</span>
<span class="sd">			The adaptive splitting method to determine the optimal estimation/inference ratios.</span>

<span class="sd">		cv_num: int, default=1</span>
<span class="sd">			The number of cross-validation to shuffle the estimation/inference samples in adaptive ratio splitting.</span>
<span class="sd">		</span>
<span class="sd">		cp: {&#39;gmean&#39;, &#39;min&#39;, &#39;hmean&#39;, &#39;Q1&#39;, &#39;hommel&#39;, &#39;cauchy&#39;} | default = &#39;hommel&#39;</span>
<span class="sd">			A method to combine p-values obtained from cross-validation. see (https://arxiv.org/pdf/1212.4966.pdf) for more detail.</span>
<span class="sd">		</span>
<span class="sd">		verbose: {0,1} | default=1</span>
<span class="sd">			If print the adaptive splitting process.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		</span>
<span class="sd">		n_opt : integer</span>
<span class="sd">			A reasonable estimation sample size.</span>

<span class="sd">		m_opt : integer</span>
<span class="sd">			A reasonable inference sample size.</span>

<span class="sd">		perturb_opt : float</span>
<span class="sd">			A reasonable perturbation level.</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">ratio_grid</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">if_reverse</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">ratio_grid</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">ratio_grid</span><span class="p">))</span>
		
		<span class="n">candidate</span><span class="p">,</span> <span class="n">Err1_lst</span><span class="p">,</span> <span class="n">ratio_lst</span><span class="p">,</span> <span class="n">P_value_lst</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;two-split&#39;</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">ratio_tmp</span> <span class="ow">in</span> <span class="n">ratio_grid</span><span class="p">:</span>
				<span class="n">ratio_tmp</span> <span class="o">=</span> <span class="n">ratio_tmp</span><span class="o">/</span><span class="mi">2</span>
				<span class="n">m_tmp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">ratio_tmp</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">m_tmp</span> <span class="o">&lt;</span> <span class="n">min_inf</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="n">n_tmp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">m_tmp</span>
				<span class="k">if</span> <span class="n">n_tmp</span> <span class="o">&lt;</span> <span class="n">min_est</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="c1"># split data</span>
				<span class="n">P_value</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cv_num</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">reset_model</span><span class="p">()</span>
					<span class="n">P_value_cv</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="c1">## generate permutated samples</span>
					<span class="n">X_perm</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="n">X_perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_perm</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
					<span class="c1">## split sample</span>
					<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X_perm</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="n">n_tmp</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
					<span class="c1"># training for full model</span>
					<span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
					
					<span class="c1"># training for mask model</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
						<span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
						<span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
					<span class="n">history_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">Z_train</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
					<span class="c1">## save model</span>
					<span class="n">path_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/ratio_tmp_model.h5&#39;</span>
					<span class="n">mask_path_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/ratio_tmp_model_mask.h5&#39;</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">mask_path_tmp</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">mask_path_tmp</span><span class="p">)</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
						<span class="n">Z_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
						<span class="n">Z_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
					<span class="c1"># evaluation</span>
					<span class="n">pred_y_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">Z_test</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_perm</span><span class="p">):</span>
						<span class="c1"># ind_test_perm = np.random.permutation(range(len(y_test)))</span>
						<span class="n">X_test_perm</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
						<span class="n">X_test_perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_test_perm</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
						<span class="c1"># X_test_perm[:,self.inf_cov[k]] = X_test_perm[:,self.inf_cov[k]][ind_test_perm,:]</span>
						<span class="n">pred_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">X_test_perm</span><span class="p">)</span>
						<span class="n">ind_inf</span><span class="p">,</span> <span class="n">ind_inf_mask</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred_y</span><span class="p">)),</span> <span class="n">train_size</span><span class="o">=</span><span class="n">m_tmp</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

						<span class="n">metric_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">y_test</span><span class="p">[</span><span class="n">ind_inf</span><span class="p">],</span> <span class="n">pred_y</span><span class="p">[</span><span class="n">ind_inf</span><span class="p">])</span>
						<span class="n">metric_mask_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">y_test</span><span class="p">[</span><span class="n">ind_inf_mask</span><span class="p">],</span> <span class="n">pred_y_mask</span><span class="p">[</span><span class="n">ind_inf_mask</span><span class="p">])</span>
						<span class="n">diff_tmp</span> <span class="o">=</span> <span class="n">metric_tmp</span> <span class="o">-</span> <span class="n">metric_mask_tmp</span>
						<span class="n">Lambda_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff_tmp</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="p">)</span>
						<span class="n">p_value_tmp</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Lambda_tmp</span><span class="p">)</span>
						<span class="n">P_value_cv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value_tmp</span><span class="p">)</span>
					<span class="n">P_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
					
					<span class="c1"># if verbose == 1:</span>
					<span class="c1"># 	print(&#39;(AdaRatio) cv: %d; p_value: %.3f, inference sample ratio: %.3f&#39; %(h, p_value_tmp, ratio_tmp))</span>
					<span class="c1"># 	print(&#39;(AdaRatio) diff: %.3f(%.3f); metric: %.3f(%.3f); metric_mask: %.3f(%.3f)&#39; %(diff_tmp.mean(), diff_tmp.std(), metric_tmp.mean(), metric_tmp.std(), metric_mask_tmp.mean(), metric_mask_tmp.std()))</span>
			
				<span class="n">P_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P_value</span><span class="p">)</span>
				<span class="c1"># print(P_value)</span>
				<span class="k">if</span> <span class="n">cv_num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="n">P_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P_value</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;gmean&#39;</span><span class="p">:</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">*</span><span class="n">gmean</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;Q1&#39;</span><span class="p">:</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">cv_num</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
					<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">cv_num</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;hmean&#39;</span><span class="p">:</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">hmean</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;hommel&#39;</span><span class="p">:</span>
						<span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">))</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">const</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">P_value</span><span class="p">)</span><span class="o">*</span><span class="n">cv_num</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">))</span>
					<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;cauchy&#39;</span><span class="p">:</span>
						<span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">((</span><span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">P_value_cv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
						<span class="n">p_value_mean</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;cp should be geometric or min.&quot;</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
				<span class="c1">## compute the type 1 error</span>
				<span class="n">Err1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">[</span><span class="n">P_value_cp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">)</span>
				<span class="n">Err1_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Err1</span><span class="p">)</span>
				<span class="c1"># P_value_lst.append(P_value)</span>
				<span class="n">ratio_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ratio_tmp</span><span class="p">)</span>

				<span class="k">if</span> <span class="n">verbose</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(AdaRatio) Est. Type 1 error: </span><span class="si">%.3f</span><span class="s1">; p_value_mean: </span><span class="si">%.3f</span><span class="s1">, inference sample ratio: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">Err1</span><span class="p">,</span> <span class="n">P_value_cp</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">ratio_tmp</span><span class="p">))</span>
					<span class="c1"># print(&#39;(AdaRatio) p_value: %.3f, inference sample ratio: %.3f&#39; %(P_value.mean(), ratio_tmp))</span>

				<span class="c1"># if P_value &gt; self.alpha:</span>
				<span class="k">if</span> <span class="n">Err1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
					<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span>
					<span class="k">if</span> <span class="n">ratio_method</span> <span class="o">==</span> <span class="s1">&#39;fuse&#39;</span><span class="p">:</span>
						<span class="n">m_opt</span> <span class="o">=</span> <span class="n">m_tmp</span>
						<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">m_opt</span>
						<span class="k">break</span>

			<span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">ratio_method</span> <span class="o">==</span> <span class="s1">&#39;close&#39;</span><span class="p">:</span>
					<span class="c1"># P_value_lst = np.array(P_value_lst)</span>
					<span class="c1"># ratio_lst = np.array(ratio_lst)</span>
					<span class="c1"># m_opt = int(ratio_lst[np.argmin(np.abs(P_value_lst - 0.5))] * len(X))</span>
					<span class="c1"># # m_opt = int(ratio_lst[np.argmax(P_value_lst)] * len(X))</span>
					<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">m_opt</span>

			<span class="k">if</span> <span class="n">found</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No ratio can control the Type 1 error, pls increase the sample size, and inference sample ratio is set as the min of ratio_grid.&quot;</span><span class="p">)</span>
				<span class="n">Err1_lst</span><span class="p">,</span> <span class="n">ratio_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">)</span>
				<span class="c1"># print(&#39;err list for the TS test: %s&#39; %Err1_lst)</span>
				<span class="n">m_opt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
				<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">m_opt</span>
			
			<span class="k">return</span> <span class="n">n_opt</span><span class="p">,</span> <span class="n">m_opt</span>

		<span class="k">if</span> <span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;one-split&#39;</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">perturb</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">perturb_grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">perturb</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">perturb_tmp</span> <span class="ow">in</span> <span class="n">perturb_grid</span><span class="p">:</span>
				<span class="c1">## stop if current perturb is enough to control the type 1 error</span>
				<span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">break</span>
				<span class="n">Err1_lst</span><span class="p">,</span> <span class="n">ratio_lst</span><span class="p">,</span> <span class="n">perturb_lst</span><span class="p">,</span> <span class="n">P_value_lst</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">ratio_tmp</span> <span class="ow">in</span> <span class="n">ratio_grid</span><span class="p">:</span>
					<span class="n">m_tmp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">ratio_tmp</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">m_tmp</span> <span class="o">&lt;</span> <span class="n">min_inf</span><span class="p">:</span>
						<span class="k">continue</span>
					<span class="n">n_tmp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">m_tmp</span>
					<span class="k">if</span> <span class="n">n_tmp</span> <span class="o">&lt;</span> <span class="n">min_est</span><span class="p">:</span>
						<span class="k">continue</span>
					<span class="c1"># split data</span>
					<span class="n">P_value</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cv_num</span><span class="p">):</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">reset_model</span><span class="p">()</span>
						<span class="n">P_value_cv</span> <span class="o">=</span> <span class="p">[]</span>
						<span class="c1">## generate permutated samples</span>
						<span class="c1"># index_perm = np.random.permutation(range(len(y)))</span>
						<span class="n">X_perm</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
						<span class="n">X_perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_perm</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
						<span class="c1"># X_perm[:,self.inf_cov[k]] = X_perm[:,self.inf_cov[k]][index_perm,:]</span>
						<span class="c1"># split samples</span>
						<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X_perm</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="n">n_tmp</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">h</span><span class="p">)</span>
						<span class="c1"># training for full model</span>
						<span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
						<span class="c1"># training for mask model</span>
						<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
							<span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
						<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
							<span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
						<span class="n">history_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">Z_train</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
						<span class="c1">## save and load models</span>
						<span class="n">path_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/ratio_tmp_model.h5&#39;</span>
						<span class="n">mask_path_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/ratio_tmp_model_mask.h5&#39;</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">mask_path_tmp</span><span class="p">)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">mask_path_tmp</span><span class="p">)</span>
						<span class="c1"># if stopping_metric == &#39;p-value&#39;:</span>
						<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
							<span class="n">Z_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
						<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
							<span class="n">Z_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
						<span class="c1"># pred_y = self.model.predict_on_batch(X_test)</span>
						<span class="n">pred_y_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">Z_test</span><span class="p">)</span>
						<span class="c1"># evaluation</span>
						<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_perm</span><span class="p">):</span>
							<span class="c1"># ind_test_perm = np.random.permutation(range(len(y_test)))</span>
							<span class="n">X_test_perm</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
							<span class="n">X_test_perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_test_perm</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
							<span class="c1"># X_test_perm[:,self.inf_cov[k]] = X_test_perm[:,self.inf_cov[k]][ind_test_perm,:]</span>
							<span class="n">pred_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">X_test_perm</span><span class="p">)</span>
							<span class="n">metric_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_y</span><span class="p">)</span>
							<span class="n">metric_mask_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred_y_mask</span><span class="p">)</span>
							<span class="n">diff_tmp</span> <span class="o">=</span> <span class="n">metric_tmp</span> <span class="o">-</span> <span class="n">metric_mask_tmp</span>
							<span class="n">Lambda_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff_tmp</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="p">)</span>
							<span class="n">p_value_tmp</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Lambda_tmp</span><span class="p">)</span>
							<span class="n">P_value_cv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value_tmp</span><span class="p">)</span>

						<span class="c1"># if verbose == 1:</span>
						<span class="c1"># 	print(&#39;(AdaRatio) diff: %.3f(%.3f); metric: %.3f(%.3f); metric_mask: %.3f(%.3f)&#39; %(diff_tmp.mean(), diff_tmp.std(), metric_tmp.mean(), metric_tmp.std(), metric_mask_tmp.mean(), metric_mask_tmp.std()))</span>
						<span class="c1"># 	print(&#39;(AdaRatio) cv: %d; p_value: %.3f, inference sample ratio: %.3f, perturb: %s&#39; %(h, p_value_tmp, ratio_tmp, perturb_tmp))</span>
						<span class="n">P_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
				
					<span class="n">P_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P_value</span><span class="p">)</span>
					<span class="c1"># print(P_value)</span>
					<span class="k">if</span> <span class="n">cv_num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;gmean&#39;</span><span class="p">:</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">*</span><span class="n">gmean</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;Q1&#39;</span><span class="p">:</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">cv_num</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">cv_num</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;hommel&#39;</span><span class="p">:</span>
							<span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">))</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">const</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">P_value</span><span class="p">)</span><span class="o">*</span><span class="n">cv_num</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">))</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;cauchy&#39;</span><span class="p">:</span>
							<span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">((</span><span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">P_value_cv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
						<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;hmean&#39;</span><span class="p">:</span>
							<span class="c1"># def h_const(y): return y**2 - cv_num*( (y+1)*np.log(y+1) - y )</span>
							<span class="c1"># sol_tmp = scipy.optimize.broyden1(h_const, xin=10., f_tol=1e-5)</span>
							<span class="c1"># a_h = (sol_tmp + cv_num)**2 / (sol_tmp+1) / cv_num</span>
							<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">hmean</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not a well-defined cp method, pls check the document.&quot;</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">P_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
					<span class="c1"># compute the type 1 error</span>
					<span class="n">P_value_cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
					<span class="c1"># print(&#39;p_value: %s&#39; %P_value_cp)</span>
					<span class="n">Err1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">[</span><span class="n">P_value_cp</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">)</span>
					<span class="n">Err1_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Err1</span><span class="p">)</span>
					
					<span class="k">if</span> <span class="n">verbose</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(AdaRatio) Est. Type 1 error: </span><span class="si">%.3f</span><span class="s1">; p_value_mean: </span><span class="si">%.3f</span><span class="s1">, inference sample ratio: </span><span class="si">%.3f</span><span class="s1">, perturb: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">Err1</span><span class="p">,</span> <span class="n">P_value_cp</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">ratio_tmp</span><span class="p">,</span> <span class="n">perturb_tmp</span><span class="p">))</span>
						<span class="c1"># print(&#39;(AdaRatio) p_value: %.3f, inference sample ratio: %.3f, perturb: %s&#39; %(P_value.mean(), ratio_tmp, perturb_tmp))</span>
					
					<span class="n">P_value_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_value_cp</span><span class="p">)</span>
					<span class="n">ratio_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ratio_tmp</span><span class="p">)</span>
					<span class="n">perturb_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">perturb_tmp</span><span class="p">)</span>
				
					<span class="c1"># if P_value &gt; self.alpha:</span>
					<span class="k">if</span> <span class="n">Err1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
						<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span>
						<span class="k">if</span> <span class="n">ratio_method</span> <span class="o">==</span> <span class="s1">&#39;fuse&#39;</span><span class="p">:</span>
							<span class="n">m_opt</span> <span class="o">=</span> <span class="n">m_tmp</span>
							<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">m_opt</span>
							<span class="n">perturb_opt</span> <span class="o">=</span> <span class="n">perturb_tmp</span>
							<span class="k">break</span>
				
				<span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">ratio_method</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
						<span class="n">Err1_lst</span><span class="p">,</span> <span class="n">ratio_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">)</span>
						<span class="n">m_opt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
						<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">m_opt</span>
						<span class="n">perturb_opt</span> <span class="o">=</span> <span class="n">perturb_tmp</span>
						
					<span class="k">if</span> <span class="n">ratio_method</span> <span class="o">==</span> <span class="s1">&#39;close&#39;</span><span class="p">:</span>
						<span class="n">P_value_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P_value_lst</span><span class="p">)</span>
						<span class="n">ratio_lst</span><span class="p">,</span> <span class="n">perturb_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perturb_lst</span><span class="p">)</span>
						<span class="n">m_opt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">P_value_lst</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
						<span class="c1"># m_opt = int(ratio_lst[np.argmax(P_value_lst)] * len(X))</span>
						<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">m_opt</span>
						<span class="n">perturb_opt</span> <span class="o">=</span> <span class="n">perturb_lst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">P_value_lst</span><span class="p">)]</span>

			<span class="k">if</span> <span class="n">found</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No ratio and perturb_level can control the Type 1 error, pls increase the perturb_level and sample size, and inference sample ratio is set as the min of ratio_grid.&quot;</span><span class="p">)</span>
				<span class="n">Err1_lst</span><span class="p">,</span> <span class="n">ratio_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">)</span>
				<span class="n">m_opt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
				<span class="n">n_opt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">m_opt</span>
				<span class="n">perturb_opt</span> <span class="o">=</span> <span class="n">perturb_lst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Err1_lst</span><span class="p">)]</span>
		
			<span class="k">return</span> <span class="n">n_opt</span><span class="p">,</span> <span class="n">m_opt</span><span class="p">,</span> <span class="n">perturb_opt</span></div>

<div class="viewcode-block" id="DnnT.testing"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.testing">[docs]</a>	<span class="k">def</span> <span class="nf">testing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fit_params</span><span class="p">,</span> <span class="n">split_params</span><span class="o">=</span><span class="p">{},</span> <span class="n">cv_num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">cp</span><span class="o">=</span><span class="s1">&#39;hommel&#39;</span><span class="p">,</span> <span class="n">inf_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return p-values for hypothesis testing for inf_cov in class Dnn.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>

<span class="sd">		X : {array-like} of shape (n_samples, dim_features)**</span>
<span class="sd">	 		Instances matrix/tensor, where n_samples in the number of samples and dim_features is the dimension of the features.</span>
<span class="sd">			 If X is vectorized feature, ``shape`` should be ``(#Samples, dim of feaures)``</span>
<span class="sd">			 If X is image/matrix data, ``shape`` should be ``(#samples, img_rows, img_cols, channel)``, that is, **X must channel_last image data**.	- **y: {array-like} of shape (n_samples,)**</span>
<span class="sd">			 Output vector/matrix relative to X.</span>
<span class="sd">	</span>
<span class="sd">		fit_params: {dict of fitting parameters}**</span>
<span class="sd">	 		See keras ``fit``: (https://keras.rstudio.com/reference/fit.html), including ``batch_size``, ``epoch``, ``callbacks``, ``validation_split``, ``validation_data``, and so on.</span>
<span class="sd">	</span>
<span class="sd">		split_params: {dict of splitting parameters}**</span>

<span class="sd">			split: {&#39;one-split&#39;, &#39;two-split&#39;}, default=&#39;one-split&#39;**</span>
<span class="sd">				one-split or two-split test statistic.</span>
<span class="sd">		</span>
<span class="sd">			perturb: float, default=None**</span>
<span class="sd">				Perturb level for the one-split test, if ``perturb = None``, then the perturb level is determined by adaptive tunning.</span>
<span class="sd">			</span>
<span class="sd">			num_perm: int, default=100**</span>
<span class="sd">				Number of permutation for determine the splitting ratio.</span>
<span class="sd">			</span>
<span class="sd">			ratio_grid: list of float (0,1), default=[.2, .4, .6, .8]**</span>
<span class="sd">				A list of estimation/inference ratios under searching.</span>
<span class="sd">			</span>
<span class="sd">			if_reverse: {0,1}, default=0**</span>
<span class="sd">				``if_reverse = 0`` indicates the loop of ``ratio_grid`` starts from smallest one to largest one; ``if_reverse = 1`` indicates the loop of ``ratio_grid`` starts from largest one to smallest one.</span>
<span class="sd">			</span>
<span class="sd">			perturb_grid: list of float, default=[.01, .05, .1, .5, 1.]**</span>
<span class="sd">				A list of perturb levels under searching. </span>
<span class="sd">			</span>
<span class="sd">			min_inf: int, default=0**</span>
<span class="sd">				The minimal size for inference sample.</span>
<span class="sd">			</span>
<span class="sd">			min_est: int, default=0**</span>
<span class="sd">				The minimal size for estimation sample.</span>
<span class="sd">			</span>
<span class="sd">			ratio_method: {&#39;fuse&#39;, &#39;close&#39;}, default=&#39;fuse&#39;**</span>
<span class="sd">				The adaptive splitting method to determine the optimal estimation/inference ratios.</span>
<span class="sd">			</span>
<span class="sd">			cv_num: int, default=1**</span>
<span class="sd">				The number of cross-validation to shuffle the estimation/inference samples in adaptive ratio splitting.</span>
<span class="sd">			</span>
<span class="sd">			cp: {&#39;gmean&#39;, &#39;min&#39;, &#39;hmean&#39;, &#39;Q1&#39;, &#39;hommel&#39;, &#39;cauchy&#39;}, default =&#39;hommel&#39;**</span>
<span class="sd">				A method to combine p-values obtained from cross-validation. see (https://arxiv.org/pdf/1212.4966.pdf) for more detail.</span>
<span class="sd">			</span>
<span class="sd">			verbose: {0,1}, default=1**</span>

<span class="sd">		cv_num: int, default=1**</span>
<span class="sd">			The number of cross-validation to shuffle the estimation/inference samples in testing.</span>
<span class="sd">		</span>
<span class="sd">		cp: {&#39;gmean&#39;, &#39;min&#39;, &#39;hmean&#39;, &#39;Q1&#39;, &#39;hommel&#39;, &#39;cauchy&#39;}, default =&#39;hommel&#39;**</span>
<span class="sd">			A method to combine p-values obtained from cross-validation.</span>
<span class="sd">		</span>
<span class="sd">		inf_ratio: float, default=None**</span>
<span class="sd">			A pre-specific inference sample ratio, if ``est_size=None``, then it is determined by adaptive splitting method ``metric``.</span>

<span class="sd">		Return</span>
<span class="sd">		------</span>
<span class="sd">		</span>
<span class="sd">		P_value: array of float [0, 1]**</span>
<span class="sd">			The p_values for target hypothesis testings.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">split_params_default</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;split&#39;</span><span class="p">:</span> <span class="s1">&#39;one-split&#39;</span><span class="p">,</span>
								<span class="s1">&#39;perturb&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
								<span class="s1">&#39;num_perm&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
								<span class="s1">&#39;ratio_grid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">,</span> <span class="o">.</span><span class="mi">8</span><span class="p">],</span>
								<span class="s1">&#39;if_reverse&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
								<span class="s1">&#39;perturb_grid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="mi">01</span><span class="p">,</span> <span class="o">.</span><span class="mi">05</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
								<span class="s1">&#39;min_inf&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
								<span class="s1">&#39;min_est&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
								<span class="s1">&#39;ratio_method&#39;</span><span class="p">:</span> <span class="s1">&#39;fuse&#39;</span><span class="p">,</span>
								<span class="s1">&#39;cv_num&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
								<span class="s1">&#39;cp&#39;</span><span class="p">:</span> <span class="s1">&#39;hommel&#39;</span><span class="p">,</span>
								<span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
		<span class="n">split_params_default</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">split_params</span><span class="p">)</span>
		<span class="n">split_params</span> <span class="o">=</span> <span class="n">split_params_default</span>

		<span class="c1">## save initial weights</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">save_init</span><span class="p">()</span>

		<span class="n">P_value</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">)):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">reset_model</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;one-split&#39;</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">inf_ratio</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;perturb&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)):</span>
					<span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">perturb_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaRatio</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="n">fit_params</span><span class="p">,</span> <span class="o">**</span><span class="n">split_params</span><span class="p">)</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-th inference; Adaptive data splitting: n: </span><span class="si">%d</span><span class="s1">; m: </span><span class="si">%d</span><span class="s1">; perturb: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">perturb_level</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">inf_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">inf_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
					<span class="n">perturb_level</span> <span class="o">=</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;perturb&#39;</span><span class="p">]</span>
			
			<span class="k">elif</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;two-split&#39;</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">inf_ratio</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
					<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adaRatio</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="n">fit_params</span><span class="p">,</span> <span class="o">**</span><span class="n">split_params</span><span class="p">)</span>
					<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-th inference; Adaptive data splitting: n: </span><span class="si">%d</span><span class="s1">; m: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">inf_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">inf_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;split method must be &#39;one-split&#39; or &#39;two-split&#39;!&quot;</span><span class="p">)</span>

			<span class="n">P_value_cv</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cv_num</span><span class="p">):</span>
				<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">h</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;two-split&#39;</span><span class="p">:</span>
					<span class="n">X_inf</span><span class="p">,</span> <span class="n">X_inf_mask</span><span class="p">,</span> <span class="n">y_inf</span><span class="p">,</span> <span class="n">y_inf_mask</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;one-split&#39;</span><span class="p">:</span>
					<span class="n">X_inf</span><span class="p">,</span> <span class="n">X_inf_mask</span><span class="p">,</span> <span class="n">y_inf</span><span class="p">,</span> <span class="n">y_inf_mask</span> <span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">X_test</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y_test</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y_test</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="c1">## prediction and inference in full model</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">reset_model</span><span class="p">()</span>
				<span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
				<span class="c1">## save and load model</span>
				<span class="n">path_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/model&#39;</span><span class="o">+</span><span class="s1">&#39;_inf&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_cv&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span>
				<span class="n">mask_path_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_path</span><span class="o">+</span><span class="s1">&#39;/model_mask&#39;</span><span class="o">+</span><span class="s1">&#39;_inf&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_cv&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">mask_path_tmp</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">mask_path_tmp</span><span class="p">)</span>
				<span class="n">pred_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">X_inf</span><span class="p">)</span>
				<span class="n">metric_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">y_inf</span><span class="p">,</span> <span class="n">pred_y</span><span class="p">)</span>
				<span class="c1"># prediction and inference in mask model</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
					<span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
					<span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
				
				<span class="bp">self</span><span class="o">.</span><span class="n">reset_model</span><span class="p">()</span>
				<span class="n">history_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Z_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
				
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
					<span class="n">Z_inf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_inf_mask</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
					<span class="n">Z_inf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_cov</span><span class="p">(</span><span class="n">X_inf_mask</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
				
				<span class="n">pred_y_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_mask</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">Z_inf</span><span class="p">)</span>
				<span class="n">metric_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">y_inf_mask</span><span class="p">,</span> <span class="n">pred_y_mask</span><span class="p">)</span>

				<span class="c1">## compute p-value</span>
				<span class="k">if</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;one-split&#39;</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">perturb_level</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
						<span class="n">diff_tmp</span> <span class="o">=</span> <span class="n">metric_full</span> <span class="o">-</span> <span class="n">metric_mask</span> <span class="o">+</span> <span class="n">metric_full</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metric_full</span><span class="p">))</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">diff_tmp</span> <span class="o">=</span> <span class="n">metric_full</span> <span class="o">-</span> <span class="n">metric_mask</span> <span class="o">+</span> <span class="n">perturb_level</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metric_full</span><span class="p">))</span>
				
				<span class="k">if</span> <span class="n">split_params</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;two-split&#39;</span><span class="p">:</span>
					<span class="n">diff_tmp</span> <span class="o">=</span> <span class="n">metric_full</span> <span class="o">-</span> <span class="n">metric_mask</span>
				
				<span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff_tmp</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="p">)</span>
				<span class="n">p_value_tmp</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Lambda</span><span class="p">)</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cv: </span><span class="si">%d</span><span class="s1">; p_value: </span><span class="si">%.3f</span><span class="s1">; diff: </span><span class="si">%.3f</span><span class="s1">(</span><span class="si">%.3f</span><span class="s1">); metric: </span><span class="si">%.3f</span><span class="s1">(</span><span class="si">%.3f</span><span class="s1">); metric_mask: </span><span class="si">%.3f</span><span class="s1">(</span><span class="si">%.3f</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p_value_tmp</span><span class="p">,</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">diff_tmp</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span> <span class="n">metric_full</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">metric_full</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span> <span class="n">metric_mask</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">metric_mask</span><span class="o">.</span><span class="n">std</span><span class="p">()))</span>

				<span class="n">P_value_cv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value_tmp</span><span class="p">)</span>
			<span class="n">P_value_cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">cv_num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;gmean&#39;</span><span class="p">:</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">*</span><span class="n">gmean</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;Q1&#39;</span><span class="p">:</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="n">cv_num</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="n">cv_num</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;hommel&#39;</span><span class="p">:</span>
					<span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">))</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="n">const</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span><span class="o">*</span><span class="n">cv_num</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">))</span>
				<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;hmean&#39;</span><span class="p">:</span>
					<span class="c1"># def h_const(y): return y**2 - cv_num*( (y+1)*np.log(y+1) - y )</span>
					<span class="c1"># sol_tmp = scipy.optimize.broyden1(h_const, xin=10., f_tol=1e-5)</span>
					<span class="c1"># a_h = (sol_tmp + cv_num)**2 / (sol_tmp+1) / cv_num</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cv_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">hmean</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>
					<span class="c1"># print(&#39;cv_p-value is %s; a_h: %.3f&#39; %(P_value_cv, a_h))</span>
				<span class="k">elif</span> <span class="n">cp</span> <span class="o">==</span> <span class="s1">&#39;cauchy&#39;</span><span class="p">:</span>
					<span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">((</span><span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">P_value_cv</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
					<span class="n">p_value_mean</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;pls input correct way to combine p-values&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">p_value_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">P_value_cv</span><span class="p">)</span>

			<span class="n">p_value_mean</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_value_mean</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">p_value_mean</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reject H0 with p_value: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">p_value_mean</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;accept H0 with p_value: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">p_value_mean</span><span class="p">)</span>

			<span class="n">P_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value_mean</span><span class="p">)</span>
		<span class="c1"># return P_value, fit_err, P_value_cv</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">p_values</span> <span class="o">=</span> <span class="n">P_value</span>
		<span class="k">return</span> <span class="n">P_value</span></div>

<div class="viewcode-block" id="DnnT.visual"><a class="viewcode-back" href="../../python-api/Dnn.html#dnn_inference.DnnT.DnnT.visual">[docs]</a>	<span class="k">def</span> <span class="nf">visual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Visualization for the inference results based on one illustrative example</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		X : array-like</span>
<span class="sd">		demo instances.</span>

<span class="sd">		y : array-like</span>
<span class="sd">		demo labels</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sorry, visual function only work for image data.&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">num_class</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">demo_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_class</span><span class="p">)])</span>
			<span class="n">X_demo</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">demo_ind</span><span class="p">]</span>

			<span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inf_cov</span><span class="p">),</span> <span class="n">num_class</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">constrained_layout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">spec</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_gridspec</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
				<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
					<span class="n">X_mask_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X_demo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
					<span class="n">X_mask_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_cov</span><span class="p">(</span><span class="n">X_mask_tmp</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">col</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
					<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">])</span>
					<span class="n">im1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_demo</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
					<span class="n">im2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_mask_tmp</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;OrRd&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
						<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;p_values: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">top</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Ben Dai

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>